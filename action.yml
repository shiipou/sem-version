name: 'SemVersion'
description: 'GitHub Action to find the next version of your project using Conventional Commit'
author: 'shiipou'

inputs:
  ALLOW_FAILURE:
    description: 'If set to "true" and this action was run on incorrect state, the action will fail. Else, it just skip.'
    required: false
    default: "true"
  LEVEL_0:
    description: "The regex to find commit type that won't increment any version tag."
    required: false
    default: '^(build|ci|docs|style|refactor|test|chore)$'
  LEVEL_1:
    description: "The regex to find commit type that will increment patch version tag."
    required: false
    default: '^(fix|perf)$'
  LEVEL_2:
    description: "The regex to find commit type that will increment minor version tag."
    required: false
    default: '^(feat)$'
  LEVEL_3:
    description: "The regex to find commit type that will increment major version tag."
    required: false
    default: "^.+!$"
  RELEASE_BRANCHES_REGEX:
    description: "The regex to find the release branch."
    required: false
    default: '^(main)$'
  PRERELEASE_BRANCHES_REGEX:
    description: "The regex to find the pre-release branch."
    required: false
    default: '^(rc|beta|hotfix)$'
  CASE_SENSITIVE:
    description: "Set if set to 'false' it didn't need to match the case of the commit message that will trigger a release. Else the case must match."
    required: false
    default: 'false'
outputs:
  VERSION:
    description: 'The next version find by semantic-release'
    value: ${{ steps.semantic-release.outputs.VERSION }}
  WILL_RELEASE:
    description: 'Only set to "true" if the release tag will be released'
    value: ${{ steps.semantic-release.outputs.WILL_RELEASE }}
  IS_PRE_RELEASE:
    description: 'Only set to "true" if the release tag will be a pre-release'
    value: ${{ steps.semantic-release.outputs.IS_PRE_RELEASE }}
  CHANGELOG:
    description: 'Changelog test to be added to the release'
    value: ${{ steps.semantic-release.outputs.CHANGELOG }}

runs:
  using: "composite"
  steps:
    - name: Semantic-Release
      id: semantic-release
      shell: bash
      env:
        ALLOW_FAILURE: '${{ inputs.ALLOW_FAILURE }}'
        LEVEL_0: '${{ inputs.LEVEL_0 }}'
        LEVEL_1: '${{ inputs.LEVEL_1 }}'
        LEVEL_2: '${{ inputs.LEVEL_2 }}'
        LEVEL_3: '${{ inputs.LEVEL_3 }}'
        RELEASE_BRANCHES_REGEX: '${{ inputs.RELEASE_BRANCHES_REGEX }}'
        PRERELEASE_BRANCHES_REGEX: '${{ inputs.PRERELEASE_BRANCHES_REGEX }}'
      run: |
        function parse_semantic_release_tag { #-> (tag: string)
          # extract major/minor/patch and channel verion tag
          if [[ $1 =~ (v([0-9]+)\.([0-9]+)\.([0-9]+)(-([a-zA-Z]+)\.([0-9]+))?)(-([0-9]+))?(-(.+))? ]]; then
            last_version="${BASH_REMATCH[1]}"
            last_channel="${BASH_REMATCH[6]}"

            major_version="${BASH_REMATCH[2]}"
            minor_version="${BASH_REMATCH[3]}"
            patch_version="${BASH_REMATCH[4]}"
            channel_version="${BASH_REMATCH[7]:-0}"

            nb_commit_since_last_release="${BASH_REMATCH[9]:-0}"
          else
            major_version="0"
            minor_version="0"
            patch_version="0"
            channel_version="0"
            nb_commit_since_last_release="0"
          fi
        }

        if $ACTIONS_STEP_DEBUG ; then set_debug_mode='set -xe'; fi
        $set_debug_mode

        CI_COMMIT_BRANCH="${GITHUB_REF#refs/heads/}"
        echo "Current branch: $CI_COMMIT_BRANCH"

        # Fetch git tags and commits.
        git fetch --all --tags >> /dev/null

        # remove the --depth=1 made by action/checkout@v3
        if [ -z "$ACT" ]; then
          git fetch --unshallow >> /dev/null
        fi

        # find last tag from the current commit sha
        _last_tag_info=$(git describe --tags ${{ github.sha }} 2>/dev/null || true)

        parse_semantic_release_tag "$_last_tag_info"

        if [[ $CI_COMMIT_BRANCH =~ $PRERELEASE_BRANCHES_REGEX && "$last_channel" != "" && "$last_channel" != "$CI_COMMIT_BRANCH" ]]; then
          parse_semantic_release_tag "$(git describe --tags --match "v*.*.*-${CI_COMMIT_BRANCH}.*" 2>/dev/null)"
        fi

        diff_path="--all"
        if [ $last_version ]; then
          echo "Last version found: $last_version"
          diff_path="${last_version}.."
        fi
        commit_list="$(git rev-list --oneline $diff_path --format=%h --no-commit-header)"
        [ $ACTIONS_STEP_DEBUG ] && echo "${commit_list}"

        correct="false"
        level=0

        declare -A CHANGELOG
        while IFS= read -r commit; do
          changelog_prefix=""
          subject="$(git log -1 --format=%s $commit | head -n1)"
          if [ "${{ inputs.CASE_SENSITIVE }}" == 'false' ]; then
            subject=${subject,,}
          fi
          
          [ $ACTIONS_STEP_DEBUG ] && echo "subject=$subject"

          # Extract the commit type
          commit_prefix="${subject%%[(: ]*}"
          [ $ACTIONS_STEP_DEBUG ] && echo "commit_prefix=$commit_prefix"

          # Check if commit type is breaking changes
          if [ "$level" -lt "3" ] && [[ $commit_prefix =~ $LEVEL_3 ]]; then
            correct="true"
            level=3

            [ $ACTIONS_STEP_DEBUG ] && echo "level=$level"
          # Check if prefix is in the array of level 2 prefix
          elif [ "$level" -lt "2" ] && [[ $commit_prefix =~ $LEVEL_2 ]]; then
            correct="true"
            level=2

            [ $ACTIONS_STEP_DEBUG ] && echo "level=$level"
          # Check if prefix is in the array of level 1 prefix
          elif [ "$level" -lt "1" ] && [[ $commit_prefix =~ $LEVEL_1 ]]; then
            correct="true"
            level=1

            [ $ACTIONS_STEP_DEBUG ] && echo "level=$level"
          # Check if prefix is in the array of level 0 prefix
          elif [[ $commit_prefix =~ $LEVEL_0 ]]; then
            correct="true"

            [ $ACTIONS_STEP_DEBUG ] && echo "level=$level"
          fi


          if [[ $commit_prefix =~ $LEVEL_3 ]]; then
            changelog_prefix=":boom: BREAKING CHANGE "
          elif [[ $commit_prefix =~ $LEVEL_2 ]]; then
            changelog_prefix=":sparkles: "
          elif [[ $commit_prefix =~ $LEVEL_1 ]]; then
            changelog_prefix=":hammer: "
          fi

          CHANGELOG["$commit_prefix"]+="- ${changelog_prefix}$subject ($commit)\n"
          echo "$subject"
        done <<< "$commit_list"

        if [[ ${CI_COMMIT_BRANCH} =~ $RELEASE_BRANCHES_REGEX && $channel_version -eq 0 || $channel_version -eq 0 ]]; then
          if [ "$level" -eq "3" ]; then
            # Increment major version tag
            echo $(( major_version++ )) >> /dev/null
          elif [ "$level" -eq "2" ]; then
            # Increment minor version tagc
            echo $(( minor_version++ )) >> /dev/null
          elif [ "$level" == "1" ]; then
            # Increment patch version tag
            echo $(( patch_version++ )) >> /dev/null
          fi
        fi

        if [[ "$level" -gt "0" && ${CI_COMMIT_BRANCH} =~ $PRERELEASE_BRANCHES_REGEX ]]; then
          # Increment channel version tag
          echo $(( channel_version++ )) >> /dev/null
        fi

        # If prefix is not found, then check ALLOW_FAILURE and fail job when needed.
        if [[ "$ALLOW_FAILURE" == "true" && "$correct" == "false" ]]; then
          echo "The commit type '$commit_prefix' didn't exist in the commit message"
          exit 2
        fi

        # If branch is release branch
        if [[ ${CI_COMMIT_BRANCH} =~ $RELEASE_BRANCHES_REGEX ]]; then
          next_version="${major_version}.${minor_version}.${patch_version}"
          if [[ "$last_version" != "v${major_version}.${minor_version}.${patch_version}" ]]; then
            MUST_RELEASE=true
          fi
          echo 'Find a release branch'

        # If branch is pre-release branch
        elif [[ ${CI_COMMIT_BRANCH} =~ $PRERELEASE_BRANCHES_REGEX ]]; then
          next_version="${major_version}.${minor_version}.${patch_version}-${CI_COMMIT_BRANCH}.${channel_version}"
          if [[ "$last_version" != "v${major_version}.${minor_version}.${patch_version}-${CI_COMMIT_BRANCH}.${channel_version}" ]]; then
            MUST_RELEASE=true
            echo 'IS_PRE_RELEASE=true' >> $GITHUB_OUTPUT
          fi
          echo 'Find a pre-release branch'

        # If branch is other branch
        elif [[ "$ALLOW_FAILURE" == "true" ]]; then
          echo "Will not update the version because current branch (${CI_COMMIT_BRANCH}) is not part of the release branches or pre-release branches."
          exit 3
        fi

        # Generate changelog
        body="# Changelog\n\n## ${next_version}\n\n"
        for prefix in "${!CHANGELOG[@]}"; do
          body+="## ${prefix}\n"
          body+="${CHANGELOG[$prefix]}\n"
        done
        body+="\n\n---\n\n**Full Changelog:** [${last_version}...${next_version}](${{ github.server_url }}/${{ github.repository }}/compare/${last_version}..v${next_version})\n"
        
        # Publish changelog as action output
        EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
        echo "CHANGELOG<<$EOF" >> "$GITHUB_OUTPUT"
        echo -n "${body}" >> "$GITHUB_OUTPUT"
        echo "$EOF" >> "$GITHUB_OUTPUT"

        search_tag="$(git tag --list v${next_version})"
        if $MUST_RELEASE && [ -z "${search_tag}" ]; then
            echo 'WILL_RELEASE=true' >> $GITHUB_OUTPUT
            echo "Will release next version: ${next_version}"
        else
            echo 'No new release needed for theses commits'
        fi
        echo "VERSION=${next_version}" >> $GITHUB_OUTPUT
